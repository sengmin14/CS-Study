🥕 SOLID
- SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙으로 SRP, OCP, LSP, DIP, ISP가 있다.
- SOLID 원칙을 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.


## 객체지향 설계과정
- 요구사항(제공해야 할 기능)을 찾고 세분화 한다.
- 기능을 알맞은 객체로 할당한다.
- 기능을 구현하는 데에 필요한 데이터를 객체에 추가한다.
- 해당 데이터를 이용하는 기능을 구현한다. 기능은 최대한 캡슐화를 적용한다.
- 객체 간에 어떻게 메소드 호출을 주고받을 지 결정한다.


## SRP (단일 책임의 원칙)
```
한 클래스는 하나의 책임만 가져야 한다.
```
- 하나의 책임이란 말은 문맥과 상황에 따라 모호한 말이다.
- 중요한 기준은 "변경"이다.
- 즉 클래스 하나에 너무 많은 기능을 입력하면 좋지 않다.
- 변경이 있을 때 파급 효과가 적으면 단일 책임의 원칙을 잘 따른 것이다.
- SRP 원칙을 적용하면 다른 클래스들이 서로 영향을 미치는 연쇄작용을 줄일 수 있다.
- 즉, 응집도는 높이고 결합도는 낮출 수 있다.
![image](https://github.com/user-attachments/assets/cec6fa91-0c6f-4bdb-a5f9-c0a7f9ce9d02)

- 위의 남자 클래스에 SRP를 적용한다가 가정해보자.
![image](https://github.com/user-attachments/assets/fc928c14-eab6-4b87-b75b-6f80584e5834)


## OCP (개방 폐쇄 원칙)
```
소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
```
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 한다.
- 쉽게 확장이 가능해야 하며 재사용할 수 있어야 한다는 뜻이다.
- OCP를 가능케 하는 중요한 메커니즘은 추상화, 다형성이다.
![image](https://github.com/user-attachments/assets/bd540678-ea96-4637-9c57-036d54e5d655)
- 위의 운전자 클래스는 마티즈 클래스와 소나타 클래스의 변화에 따라 행동이 의존적으로 변하게 된다.
![image](https://github.com/user-attachments/assets/083d1b85-2524-4ae2-879a-f39b05c57be4)
- 다음과 같이 마티즈 클래스와 소나타 클래스 위에 자동차라는 상위 클래스를 두면, 운전자는 마티즈와 소나타 클래스의 변경사항에 영향을 받지 않을 수 있다.


## LSP (리스코프 치환 원칙)
```
서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
```
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 이는 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것을 말하며, 다형성을 지원하기 위한 원칙이다.
- 인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.
![image](https://github.com/user-attachments/assets/908918e6-15f8-4fb3-a8c3-59dcf14e2361)


## ISP (인터페이스 분리 원칙)
```
클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다.
```
- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
- 특정 클라이언트를 위안 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다는 뜻으로, 하나의 큰 인터페이스를 상속 받기 보다는 인터페이스를 구체적으로 작은 단위들로 분리시켜 꼭 필요한 인터페이스만 상속하자는 의미
- SRP가 클래스의 단일책임만 강조했다면 ISP는 인터페이스의 단일책임을 강조한다.
![image](https://github.com/user-attachments/assets/5b69455c-f304-4734-aa09-7432aefdcd49)


- 위의 SRP 예제에서 남자 클래스를 단일 책임을 갖는 클래스들로 나누었다.
- 이것은 너무 많은 클래스 구현을 불러 온다.
- ISP를 적용하면 다양한 역할을 인터페이스로 만들고, 남자 클래스는 그 인터페이스를 구현한 클래스로 만들 수 있다.
![image](https://github.com/user-attachments/assets/81a8537b-1a03-49e4-ba28-6726aa14a73c)


## DIP (의존관계 역전 원칙)
```
추상화된 것은 구체적인 것에 의존하면 안된다.
구체적인 것이 추상화된 것에 의존해야 한다.
```

- 구현 클래스에 의존하지 말고, 인터페이스에 워존하라는 뜻이다.
- 구현체에 의존하게 되면 변경이 아주 어려워진다.
- 즉, 인터페이스를 적극적으로 활용하라는 의미이다.
![image](https://github.com/user-attachments/assets/18bf079a-7a42-41ae-901e-56d667063091)
- 자동차는 스노우타이어에 의존하고 있다.
![image](https://github.com/user-attachments/assets/fead3093-6755-412c-a2db-956cbac2c273)
- 해당 관계를 타이어 인터페이스로 역전 시킨다. 이것이 의존성 주임(DI)이다.
- 상위클래스일 수록, 인터페이스일 수록, 추상 클래스일 수록 변하지 않을 가능성이 크다.
- 하위클래스나 구체클래스가 아닌 더 추상적인 것에 의존하라는 것이 의존 역전 원칙이다.
