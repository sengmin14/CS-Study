# 🥕 SOLID
- SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙으로 SRP, OCP, LSP, DIP, ISP가 있다.
- SOLID 원칙을 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 된다.


## 객체지향 설계과정
- 요구사항(제공해야 할 기능)을 찾고 세분화 한다.
- 기능을 알맞은 객체로 할당한다.
- 기능을 구현하는 데에 필요한 데이터를 객체에 추가한다.
- 해당 데이터를 이용하는 기능을 구현한다. 기능은 최대한 캡슐화를 적용한다.
- 객체 간에 어떻게 메소드 호출을 주고받을 지 결정한다.

## SRP (단일 책임의 원칙)
```
한 클래스는 하나의 책임만 가져야 한다.
```
- 하나의 책임이란 말은 문맥과 상황에 따라 모호한 말이다.
- 중요한 기준은 "변경"이다.
- 즉 클래스 하나에 너무 많은 기능을 입력하면 좋지 않다.
- 변경이 있을 때 파급 효과가 적으면 단일 책임의 원칙을 잘 따른 것이다.
- SRP 원칙을 적용하면 다른 클래스들이 서로 영향을 미치는 연쇄작용을 줄일 수 있다.
- 즉, 응집도는 높이고 결합도는 낮출 수 있다.
![image](https://github.com/user-attachments/assets/cec6fa91-0c6f-4bdb-a5f9-c0a7f9ce9d02)

- 위의 남자 클래스에 SRP를 적용한다가 가정해보자.
![image](https://github.com/user-attachments/assets/fc928c14-eab6-4b87-b75b-6f80584e5834)


## OCP (개방 폐쇄 원칙)
```
소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
```
- 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 한다.
- 쉽게 확장이 가능해야 하며 재사용할 수 있어야 한다는 뜻이다.
- OCP를 가능케 하는 중요한 메커니즘은 추상화, 다형성이다.
![image](https://github.com/user-attachments/assets/bd540678-ea96-4637-9c57-036d54e5d655)
- 위의 운전자 클래스는 마티즈 클래스와 소나타 클래스의 변화에 따라 행동이 의존적으로 변하게 된다.
![image](https://github.com/user-attachments/assets/083d1b85-2524-4ae2-879a-f39b05c57be4)
- 다음과 같이 마티즈 클래스와 소나타 클래스 위에 자동차라는 상위 클래스를 두면, 운전자는 마티즈와 소나타 클래스의 변경사항에 영향을 받지 않을 수 있다.
